name: Claude Auto-Approve

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  claude-review:
    name: claude-review
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get PR context
        id: pr-context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get changed files
          gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' > /tmp/files.txt
          FILE_COUNT=$(wc -l < /tmp/files.txt | tr -d ' ')
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          
          # Get the diff directly from GitHub API
          gh pr diff ${{ github.event.pull_request.number }} > /tmp/pr_diff.txt
          
          # Get diff stats
          gh pr view ${{ github.event.pull_request.number }} --json additions,deletions,changedFiles \
            --jq '"additions: \(.additions), deletions: \(.deletions), files: \(.changedFiles)"' > /tmp/stats.txt

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude CLI
        run: npm install -g @anthropic-ai/claude-code

      - name: Analyze with Claude
        id: analyze
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
        run: |
          # Prepare the prompt
          cat > /tmp/prompt.txt << 'PROMPT_EOF'
          You are a principal software engineer reviewing a pull request. Analyze the changes and provide a structured assessment.
          
          ## Your Task
          
          1. Determine if the changes are ISOLATED or EXTENSIVE:
             - ISOLATED: Focused on a single feature, bug fix, or small improvement. Few files, clear scope, low blast radius.
             - EXTENSIVE: Spans multiple systems, architectural changes, many files, or high blast radius.
          
          2. Identify any MAJOR ISSUES (things that would block merge):
             - Security vulnerabilities
             - Critical bugs
             - Breaking API changes without migration
             - Missing error handling for critical paths
             - Obvious logic errors
             - Changes that are dangerous from an access, approval, or compliance perspective
          
          Note: Style issues, minor improvements, or suggestions are NOT major issues.
          
          ## Response Rules
          
          For major_issues: include file path and issue description. Line number is optional.
          If no issues, use empty array.
          
          Set "recommendation" to "APPROVE" only if BOTH:
          1. scope is "ISOLATED"
          2. major_issues is empty
          
          Otherwise, set "recommendation" to "REVIEW_NEEDED".
          PROMPT_EOF
          
          # Add PR context (using env vars to prevent command injection from untrusted input)
          {
            echo ""
            echo "## PR Information"
            echo ""
            echo "**Title:** $PR_TITLE"
            echo "**Author:** $PR_AUTHOR"
            echo "**Stats:** $(cat /tmp/stats.txt)"
            echo ""
            echo "**Changed Files:**"
            cat /tmp/files.txt
            echo ""
            echo "**Diff:**"
            cat /tmp/pr_diff.txt
          } >> /tmp/prompt.txt
          
          # Define JSON schema for structured output
          JSON_SCHEMA='{
            "type": "object",
            "properties": {
              "scope": { "type": "string", "enum": ["ISOLATED", "EXTENSIVE"] },
              "scope_reasoning": { "type": "string" },
              "major_issues": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "line": { "type": "integer" },
                    "issue": { "type": "string" }
                  },
                  "required": ["file", "issue"]
                }
              },
              "summary": { "type": "string" },
              "recommendation": { "type": "string", "enum": ["APPROVE", "REVIEW_NEEDED"] }
            },
            "required": ["scope", "scope_reasoning", "major_issues", "summary", "recommendation"]
          }'
          
          # Run Claude CLI with JSON schema enforcement (using Opus for highest quality review)
          RESPONSE=$(claude -p "$(cat /tmp/prompt.txt)" --model opus --output-format json --json-schema "$JSON_SCHEMA" 2>&1) || true
          
          echo "Raw Claude Response:"
          echo "$RESPONSE"
          
          # Check for errors in the response
          IS_ERROR=$(echo "$RESPONSE" | jq -r '.is_error // false' 2>/dev/null || echo "false")
          ERROR_MSG=$(echo "$RESPONSE" | jq -r '.result // empty' 2>/dev/null || echo "")
          
          if [ "$IS_ERROR" = "true" ] || [ -z "$RESPONSE" ] || ! echo "$RESPONSE" | jq -e '.' > /dev/null 2>&1; then
            echo "Claude CLI error detected"
            echo "has_error=true" >> $GITHUB_OUTPUT
            echo "should_approve=false" >> $GITHUB_OUTPUT
            
            # Build error comment
            {
              echo "## Claude Auto-Approve Review"
              echo ""
              echo "‚ö†Ô∏è **Error:** Claude analysis failed"
              echo ""
              if [ -n "$ERROR_MSG" ]; then
                echo "$ERROR_MSG"
              else
                echo "No response received from Claude CLI."
              fi
              echo ""
              if [ -n "$RESPONSE" ]; then
                echo "<details>"
                echo "<summary>Raw response</summary>"
                echo ""
                echo "\`\`\`json"
                echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
                echo "\`\`\`"
                echo "</details>"
                echo ""
              fi
              echo "---"
              echo "Conclusion: üëÄ **Manual review needed** (auto-review failed)"
            } > /tmp/comment.txt
            
            cat /tmp/comment.txt
            echo "parse_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Parse successful response (--json-schema puts output in .structured_output)
          if echo "$RESPONSE" | jq -e '.structured_output' > /dev/null 2>&1; then
            # With --json-schema, the structured output is directly in .structured_output
            ANALYSIS=$(echo "$RESPONSE" | jq -c '.structured_output')
          elif echo "$RESPONSE" | jq -e '.result' > /dev/null 2>&1; then
            # Fallback to .result if structured_output not present
            RESULT_RAW=$(echo "$RESPONSE" | jq -r '.result')
            if echo "$RESULT_RAW" | jq -e '.' > /dev/null 2>&1; then
              ANALYSIS="$RESULT_RAW"
            else
              ANALYSIS="{}"
            fi
          else
            ANALYSIS="{}"
          fi
          
          echo "Parsed Analysis:"
          echo "$ANALYSIS" | jq '.' 2>/dev/null || echo "$ANALYSIS"
          
          # Validate we have the expected fields
          if ! echo "$ANALYSIS" | jq -e '.recommendation' > /dev/null 2>&1; then
            echo "Invalid analysis format - missing required fields"
            echo "has_error=true" >> $GITHUB_OUTPUT
            echo "should_approve=false" >> $GITHUB_OUTPUT
            
            {
              echo "## Claude Auto-Approve Review"
              echo ""
              echo "‚ö†Ô∏è **Error:** Could not parse Claude's response"
              echo ""
              echo "<details>"
              echo "<summary>Raw response</summary>"
              echo ""
              echo "\`\`\`json"
              echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
              echo "\`\`\`"
              echo "</details>"
              echo ""
              echo "---"
              echo "Conclusion: üëÄ **Manual review needed** (auto-review failed)"
            } > /tmp/comment.txt
            
            cat /tmp/comment.txt
            echo "parse_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "has_error=false" >> $GITHUB_OUTPUT
          
          # Extract fields
          RECOMMENDATION=$(echo "$ANALYSIS" | jq -r '.recommendation // "REVIEW_NEEDED"')
          SUMMARY=$(echo "$ANALYSIS" | jq -r '.summary // "Unable to summarize"')
          SCOPE=$(echo "$ANALYSIS" | jq -r '.scope // "EXTENSIVE"')
          SCOPE_REASONING=$(echo "$ANALYSIS" | jq -r '.scope_reasoning // ""')
          MAJOR_ISSUES=$(echo "$ANALYSIS" | jq -c '.major_issues // []')
          ISSUES_COUNT=$(echo "$MAJOR_ISSUES" | jq 'length')
          
          # Set outputs
          if [ "$RECOMMENDATION" = "APPROVE" ]; then
            echo "should_approve=true" >> $GITHUB_OUTPUT
          else
            echo "should_approve=false" >> $GITHUB_OUTPUT
          fi
          
          # Build comment body
          {
            echo "## Claude Auto-Approve Review"
            echo ""
            echo "**Summary:** $SUMMARY"
            echo ""
            echo "**Scope:** $SCOPE"
            echo "> $SCOPE_REASONING"
            echo ""
            if [ "$ISSUES_COUNT" -gt 0 ]; then
              echo "**Major Issues Found:** $ISSUES_COUNT"
              echo ""
              echo "$MAJOR_ISSUES" | jq -r '.[] | "- **\(.file):\(.line // "N/A")** - \(.issue)"'
            else
              echo "**Major Issues Found:** None"
            fi
            echo ""
            echo "---"
            if [ "$RECOMMENDATION" = "APPROVE" ]; then
              echo "Conclusion: ‚úÖ **Auto-approved** (isolated changes, no major issues)"
            else
              echo "üëÄ **Manual review needed**"
            fi
          } > /tmp/comment.txt
          
          cat /tmp/comment.txt

      - name: Post or update review comment
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          
          # Find existing comment by searching for our title (GitHub strips HTML comments)
          EXISTING_COMMENT_ID=$(gh api "repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
            --jq '.[] | select(.body | startswith("## Claude Auto-Approve Review")) | .id' | head -1)
          
          if [ -n "$EXISTING_COMMENT_ID" ]; then
            echo "Updating existing comment: $EXISTING_COMMENT_ID"
            gh api "repos/${{ github.repository }}/issues/comments/${EXISTING_COMMENT_ID}" \
              -X PATCH \
              -f body="$(cat /tmp/comment.txt)"
          else
            echo "Creating new comment"
            gh pr comment "$PR_NUMBER" --body "$(cat /tmp/comment.txt)"
          fi

      - name: Auto-approve PR
        if: steps.analyze.outputs.should_approve == 'true'
        uses: hmarr/auto-approve-action@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
