name: Claude Auto-Approve

on:
  pull_request:
    types: [opened, ready_for_review]
    branches: [main]

jobs:
  claude-review:
    name: claude-review
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git diff/log commands

      - name: Setup git branches
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_HEAD_REF: ${{ github.event.pull_request.head.ref }}
          PR_BASE_REF: ${{ github.event.pull_request.base.ref }}
        run: |
          # Fetch and checkout PR branch (using env vars to avoid shell injection)
          git fetch origin "$PR_HEAD_REF"
          git checkout "$PR_HEAD_REF"
          
          # Fetch base branch for comparison
          git fetch origin "$PR_BASE_REF"

      - name: Get PR context
        id: pr-context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get changed files
          gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' > /tmp/files.txt
          FILE_COUNT=$(wc -l < /tmp/files.txt | tr -d ' ')
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          
          # Get diff stats
          gh pr view ${{ github.event.pull_request.number }} --json additions,deletions,changedFiles \
            --jq '"additions: \(.additions), deletions: \(.deletions), files: \(.changedFiles)"' > /tmp/stats.txt

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude CLI
        run: npm install -g @anthropic-ai/claude-code

      - name: Analyze with Claude
        id: analyze
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Load file contents into env vars for template substitution
          export PR_STATS="$(cat /tmp/stats.txt)"
          export CHANGED_FILES="$(cat /tmp/files.txt)"
          
          # Hydrate prompt template with envsubst
          envsubst < .github/prompts/auto-approve-review-prompt.md > /tmp/prompt.txt
          
          # Define JSON schema for structured output
          JSON_SCHEMA='{
            "type": "object",
            "properties": {
              "scope": { "type": "string", "enum": ["ISOLATED", "ISOLATED_SENSITIVE", "EXTENSIVE"] },
              "scope_reasoning": { "type": "string" },
              "major_issues": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "line": { "type": "integer" },
                    "issue": { "type": "string" }
                  },
                  "required": ["file", "issue"]
                }
              },
              "medium_issues": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "line": { "type": "integer" },
                    "issue": { "type": "string" }
                  },
                  "required": ["file", "issue"]
                }
              },
              "summary": { "type": "string" },
              "recommendation": { "type": "string", "enum": ["APPROVE", "REVIEW_NEEDED"] }
            },
            "required": ["scope", "scope_reasoning", "major_issues", "medium_issues", "summary", "recommendation"]
          }'
          
          # Run Claude CLI with JSON schema enforcement (using Opus for highest quality review)
          # Allow only safe read-only git commands and file reading
          # Read prompt from stdin using -p -
          RESPONSE=$(claude -p - \
            --model opus \
            --output-format json \
            --json-schema "$JSON_SCHEMA" \
            --allowedTools "Bash(git diff*)" "Bash(git log*)" "Bash(git show*)" "Bash(git status*)" "Read" "Grep" "Glob" \
            < /tmp/prompt.txt 2>&1) || true
          
          echo "Raw Claude Response:"
          echo "$RESPONSE"
          
          # Check for errors in the response
          IS_ERROR=$(echo "$RESPONSE" | jq -r '.is_error // false' 2>/dev/null || echo "false")
          ERROR_MSG=$(echo "$RESPONSE" | jq -r '.result // empty' 2>/dev/null || echo "")
          
          if [ "$IS_ERROR" = "true" ] || [ -z "$RESPONSE" ] || ! echo "$RESPONSE" | jq -e '.' > /dev/null 2>&1; then
            echo "::error::Claude CLI error detected"
            if [ -n "$ERROR_MSG" ]; then
              echo "$ERROR_MSG"
            fi
            if [ -n "$RESPONSE" ]; then
              echo "Raw response:"
              echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
            fi
            exit 1
          fi
          
          # Parse successful response (--json-schema puts output in .structured_output)
          if echo "$RESPONSE" | jq -e '.structured_output' > /dev/null 2>&1; then
            # With --json-schema, the structured output is directly in .structured_output
            ANALYSIS=$(echo "$RESPONSE" | jq -c '.structured_output')
          elif echo "$RESPONSE" | jq -e '.result' > /dev/null 2>&1; then
            # Fallback to .result if structured_output not present
            RESULT_RAW=$(echo "$RESPONSE" | jq -r '.result')
            if echo "$RESULT_RAW" | jq -e '.' > /dev/null 2>&1; then
              ANALYSIS="$RESULT_RAW"
            else
              ANALYSIS="{}"
            fi
          else
            ANALYSIS="{}"
          fi
          
          echo "Parsed Analysis:"
          echo "$ANALYSIS" | jq '.' 2>/dev/null || echo "$ANALYSIS"
          
          # Validate we have the expected fields
          if ! echo "$ANALYSIS" | jq -e '.recommendation' > /dev/null 2>&1; then
            echo "::error::Invalid analysis format - missing required fields"
            echo "Raw response:"
            echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
            exit 1
          fi
          
          # Extract fields
          RECOMMENDATION=$(echo "$ANALYSIS" | jq -r '.recommendation // "REVIEW_NEEDED"')
          SUMMARY=$(echo "$ANALYSIS" | jq -r '.summary // "Unable to summarize"')
          SCOPE=$(echo "$ANALYSIS" | jq -r '.scope // "EXTENSIVE"')
          SCOPE_REASONING=$(echo "$ANALYSIS" | jq -r '.scope_reasoning // ""')
          MAJOR_ISSUES=$(echo "$ANALYSIS" | jq -c '.major_issues // []')
          MAJOR_ISSUES_COUNT=$(echo "$MAJOR_ISSUES" | jq 'length')
          MEDIUM_ISSUES=$(echo "$ANALYSIS" | jq -c '.medium_issues // []')
          MEDIUM_ISSUES_COUNT=$(echo "$MEDIUM_ISSUES" | jq 'length')
          
          # Set outputs
          if [ "$RECOMMENDATION" = "APPROVE" ]; then
            echo "should_approve=true" >> $GITHUB_OUTPUT
          else
            echo "should_approve=false" >> $GITHUB_OUTPUT
            echo "Review needed: $SUMMARY"
          fi
          
          # Build comment only for approvals
          if [ "$RECOMMENDATION" = "APPROVE" ]; then
            {
              echo "## Claude Auto-Approve Review"
              echo ""
              echo "**Summary:** $SUMMARY"
              echo ""
              echo "**Scope:** $SCOPE"
              echo "> $SCOPE_REASONING"
              echo ""
              echo "---"
              echo "Conclusion: âœ… **Auto-approved** (isolated changes, no issues)"
            } > /tmp/comment.txt
            
            cat /tmp/comment.txt
          fi

      - name: Post approval comment
        if: steps.analyze.outputs.should_approve == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "$(cat /tmp/comment.txt)"

      - name: Auto-approve PR
        if: steps.analyze.outputs.should_approve == 'true'
        uses: hmarr/auto-approve-action@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
